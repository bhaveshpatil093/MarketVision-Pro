{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nimport toast from 'react-hot-toast';\nexport const useWebSocket = () => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const [latency, setLatency] = useState(0);\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\n  const [isMockMode, setIsMockMode] = useState(false);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef();\n  const pingIntervalRef = useRef();\n  const lastPingRef = useRef(0);\n  const subscriptionsRef = useRef(new Set());\n  const reconnectAttemptsRef = useRef(0);\n  const maxReconnectAttempts = 2; // Reduced from 3 to 2\n  const mockLatencyRef = useRef();\n  const connectionTimeoutRef = useRef();\n  const connect = useCallback(() => {\n    var _wsRef$current;\n    if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN) {\n      return; // Already connected\n    }\n\n    // Clear any existing timeout\n    if (connectionTimeoutRef.current) {\n      clearTimeout(connectionTimeoutRef.current);\n    }\n    try {\n      setConnectionStatus('connecting');\n\n      // Quick backend availability check (0.5 seconds)\n      const quickCheck = fetch('http://localhost:8000/health', {\n        method: 'GET',\n        signal: AbortSignal.timeout(500) // 500ms timeout\n      }).catch(() => {\n        // If quick check fails, immediately switch to mock mode\n        setConnectionStatus('error');\n        setIsMockMode(true);\n        toast.success('Using simulated data mode. All features are fully functional!', {\n          duration: 3000,\n          icon: 'ðŸŽ¯'\n        });\n        return null;\n      });\n      quickCheck.then(response => {\n        if (!response || !response.ok) {\n          // Backend not available, switch to mock mode\n          setConnectionStatus('error');\n          setIsMockMode(true);\n          toast.success('Using simulated data mode. All features are fully functional!', {\n            duration: 3000,\n            icon: 'ðŸŽ¯'\n          });\n          return;\n        }\n\n        // Backend is available, proceed with WebSocket connection\n        // Set a very short connection timeout (1.5 seconds)\n        connectionTimeoutRef.current = setTimeout(() => {\n          var _wsRef$current2;\n          if (((_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.readyState) !== WebSocket.OPEN) {\n            var _wsRef$current3;\n            (_wsRef$current3 = wsRef.current) === null || _wsRef$current3 === void 0 ? void 0 : _wsRef$current3.close();\n            setConnectionStatus('error');\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n          }\n        }, 1500); // Reduced from 2 seconds to 1.5 seconds\n\n        const ws = new WebSocket('ws://localhost:8000/ws/market-data');\n        wsRef.current = ws;\n        ws.onopen = () => {\n          if (connectionTimeoutRef.current) {\n            clearTimeout(connectionTimeoutRef.current);\n          }\n          setIsConnected(true);\n          setConnectionStatus('connected');\n          setIsMockMode(false);\n          reconnectAttemptsRef.current = 0;\n          console.log('WebSocket connected');\n\n          // Start ping interval\n          pingIntervalRef.current = setInterval(() => {\n            if (ws.readyState === WebSocket.OPEN) {\n              lastPingRef.current = Date.now();\n              ws.send(JSON.stringify({\n                type: 'ping'\n              }));\n            }\n          }, 30000);\n\n          // Resubscribe to symbols\n          subscriptionsRef.current.forEach(symbol => {\n            ws.send(JSON.stringify({\n              type: 'subscribe',\n              symbol\n            }));\n          });\n          toast.success('Connected to real-time data feed', {\n            duration: 2000,\n            icon: 'âœ…'\n          });\n        };\n        ws.onmessage = event => {\n          try {\n            const message = JSON.parse(event.data);\n            if (message.type === 'pong') {\n              const now = Date.now();\n              const newLatency = now - lastPingRef.current;\n              setLatency(newLatency);\n            } else if (message.type === 'market_data_update') {\n              console.log('Market data update:', message);\n            } else if (message.type === 'subscription_response') {\n              if (message.symbol && message.success) {\n                console.log(`Subscribed to ${message.symbol}`);\n              }\n            } else if (message.type === 'unsubscription_response') {\n              if (message.symbol && message.success) {\n                console.log(`Unsubscribed from ${message.symbol}`);\n              }\n            }\n          } catch (error) {\n            console.error('Failed to parse WebSocket message:', error);\n          }\n        };\n        ws.onclose = event => {\n          if (connectionTimeoutRef.current) {\n            clearTimeout(connectionTimeoutRef.current);\n          }\n          setIsConnected(false);\n          setConnectionStatus('disconnected');\n          console.log('WebSocket disconnected:', event.code, event.reason);\n\n          // Clear intervals\n          if (pingIntervalRef.current) {\n            clearInterval(pingIntervalRef.current);\n          }\n\n          // If this is the first connection attempt and it fails, switch to mock mode immediately\n          if (reconnectAttemptsRef.current === 0) {\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n            return;\n          }\n\n          // Attempt to reconnect if not a normal closure and we haven't exceeded max attempts\n          if (event.code !== 1000 && reconnectAttemptsRef.current < maxReconnectAttempts) {\n            reconnectAttemptsRef.current++;\n            const delay = Math.min(500 * Math.pow(2, reconnectAttemptsRef.current), 3000); // Max 3s delay, reduced from 10s\n\n            console.log(`Attempting to reconnect in ${delay}ms (attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts})...`);\n            reconnectTimeoutRef.current = setTimeout(() => {\n              connect();\n            }, delay);\n          } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n            setConnectionStatus('error');\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n          }\n        };\n        ws.onerror = error => {\n          if (connectionTimeoutRef.current) {\n            clearTimeout(connectionTimeoutRef.current);\n          }\n          console.error('WebSocket error:', error);\n          setConnectionStatus('error');\n\n          // If this is the first connection attempt, switch to mock mode immediately\n          if (reconnectAttemptsRef.current === 0) {\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n          }\n        };\n      });\n    } catch (error) {\n      if (connectionTimeoutRef.current) {\n        clearTimeout(connectionTimeoutRef.current);\n      }\n      console.error('Failed to create WebSocket connection:', error);\n      setConnectionStatus('error');\n      setIsMockMode(true);\n      toast.success('Using simulated data mode. All features are fully functional!', {\n        duration: 3000,\n        icon: 'ðŸŽ¯'\n      });\n    }\n  }, []);\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, 'Client disconnect');\n      wsRef.current = null;\n    }\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    if (connectionTimeoutRef.current) {\n      clearTimeout(connectionTimeoutRef.current);\n    }\n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n    }\n    if (mockLatencyRef.current) {\n      clearInterval(mockLatencyRef.current);\n    }\n    setIsConnected(false);\n    setConnectionStatus('disconnected');\n    setIsMockMode(false);\n    reconnectAttemptsRef.current = 0;\n  }, []);\n  const subscribe = useCallback(symbol => {\n    var _wsRef$current4;\n    if (((_wsRef$current4 = wsRef.current) === null || _wsRef$current4 === void 0 ? void 0 : _wsRef$current4.readyState) === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'subscribe',\n        symbol\n      }));\n      subscriptionsRef.current.add(symbol);\n    } else {\n      // Store subscription for when connection is established\n      subscriptionsRef.current.add(symbol);\n    }\n  }, []);\n  const unsubscribe = useCallback(symbol => {\n    var _wsRef$current5;\n    if (((_wsRef$current5 = wsRef.current) === null || _wsRef$current5 === void 0 ? void 0 : _wsRef$current5.readyState) === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'unsubscribe',\n        symbol\n      }));\n    }\n    subscriptionsRef.current.delete(symbol);\n  }, []);\n  const sendMessage = useCallback(message => {\n    var _wsRef$current6;\n    if (((_wsRef$current6 = wsRef.current) === null || _wsRef$current6 === void 0 ? void 0 : _wsRef$current6.readyState) === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('WebSocket not connected, cannot send message:', message);\n    }\n  }, []);\n\n  // Start mock latency simulation when in mock mode\n  useEffect(() => {\n    if (isMockMode) {\n      mockLatencyRef.current = setInterval(() => {\n        setLatency(Math.floor(Math.random() * 30) + 5); // Random latency between 5-35ms (faster)\n      }, 3000); // Update every 3 seconds instead of 5\n    } else {\n      if (mockLatencyRef.current) {\n        clearInterval(mockLatencyRef.current);\n      }\n    }\n    return () => {\n      if (mockLatencyRef.current) {\n        clearInterval(mockLatencyRef.current);\n      }\n    };\n  }, [isMockMode]);\n\n  // Auto-connect on mount with immediate fallback\n  useEffect(() => {\n    // Start connection attempt\n    connect();\n\n    // Set a very short fallback timeout (1.5 seconds)\n    const fallbackTimeout = setTimeout(() => {\n      if (!isConnected && !isMockMode) {\n        setIsMockMode(true);\n        toast.success('Using simulated data mode. All features are fully functional!', {\n          duration: 3000,\n          icon: 'ðŸŽ¯'\n        });\n      }\n    }, 1500);\n    return () => {\n      clearTimeout(fallbackTimeout);\n      disconnect();\n    };\n  }, [connect, disconnect, isConnected, isMockMode]);\n  return {\n    isConnected,\n    latency,\n    subscribe,\n    unsubscribe,\n    sendMessage,\n    connectionStatus,\n    isMockMode\n  };\n};\n_s(useWebSocket, \"DCpKg4qlTwd6r2F3/pajNAPnbMo=\");","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","toast","useWebSocket","_s","isConnected","setIsConnected","latency","setLatency","connectionStatus","setConnectionStatus","isMockMode","setIsMockMode","wsRef","reconnectTimeoutRef","pingIntervalRef","lastPingRef","subscriptionsRef","Set","reconnectAttemptsRef","maxReconnectAttempts","mockLatencyRef","connectionTimeoutRef","connect","_wsRef$current","current","readyState","WebSocket","OPEN","clearTimeout","quickCheck","fetch","method","signal","AbortSignal","timeout","catch","success","duration","icon","then","response","ok","setTimeout","_wsRef$current2","_wsRef$current3","close","ws","onopen","console","log","setInterval","Date","now","send","JSON","stringify","type","forEach","symbol","onmessage","event","message","parse","data","newLatency","error","onclose","code","reason","clearInterval","delay","Math","min","pow","onerror","disconnect","subscribe","_wsRef$current4","add","unsubscribe","_wsRef$current5","delete","sendMessage","_wsRef$current6","warn","floor","random","fallbackTimeout"],"sources":["/Users/bhaveshpatil/Developer/HFT Projects/1/MarketVision-Pro/frontend/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\nimport toast from 'react-hot-toast';\n\ninterface WebSocketMessage {\n  type: string;\n  symbol?: string;\n  data?: any;\n  timestamp: string;\n  success?: boolean;\n}\n\ninterface UseWebSocketReturn {\n  isConnected: boolean;\n  latency: number;\n  subscribe: (symbol: string) => void;\n  unsubscribe: (symbol: string) => void;\n  sendMessage: (message: any) => void;\n  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';\n  isMockMode: boolean;\n}\n\nexport const useWebSocket = (): UseWebSocketReturn => {\n  const [isConnected, setIsConnected] = useState(false);\n  const [latency, setLatency] = useState(0);\n  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected');\n  const [isMockMode, setIsMockMode] = useState(false);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();\n  const pingIntervalRef = useRef<NodeJS.Timeout>();\n  const lastPingRef = useRef<number>(0);\n  const subscriptionsRef = useRef<Set<string>>(new Set());\n  const reconnectAttemptsRef = useRef<number>(0);\n  const maxReconnectAttempts = 2; // Reduced from 3 to 2\n  const mockLatencyRef = useRef<NodeJS.Timeout>();\n  const connectionTimeoutRef = useRef<NodeJS.Timeout>();\n\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return; // Already connected\n    }\n\n    // Clear any existing timeout\n    if (connectionTimeoutRef.current) {\n      clearTimeout(connectionTimeoutRef.current);\n    }\n\n    try {\n      setConnectionStatus('connecting');\n      \n      // Quick backend availability check (0.5 seconds)\n      const quickCheck = fetch('http://localhost:8000/health', { \n        method: 'GET',\n        signal: AbortSignal.timeout(500) // 500ms timeout\n      }).catch(() => {\n        // If quick check fails, immediately switch to mock mode\n        setConnectionStatus('error');\n        setIsMockMode(true);\n        toast.success('Using simulated data mode. All features are fully functional!', {\n          duration: 3000,\n          icon: 'ðŸŽ¯'\n        });\n        return null;\n      });\n\n      quickCheck.then((response) => {\n        if (!response || !response.ok) {\n          // Backend not available, switch to mock mode\n          setConnectionStatus('error');\n          setIsMockMode(true);\n          toast.success('Using simulated data mode. All features are fully functional!', {\n            duration: 3000,\n            icon: 'ðŸŽ¯'\n          });\n          return;\n        }\n\n        // Backend is available, proceed with WebSocket connection\n        // Set a very short connection timeout (1.5 seconds)\n        connectionTimeoutRef.current = setTimeout(() => {\n          if (wsRef.current?.readyState !== WebSocket.OPEN) {\n            wsRef.current?.close();\n            setConnectionStatus('error');\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n          }\n        }, 1500); // Reduced from 2 seconds to 1.5 seconds\n\n        const ws = new WebSocket('ws://localhost:8000/ws/market-data');\n        wsRef.current = ws;\n\n        ws.onopen = () => {\n          if (connectionTimeoutRef.current) {\n            clearTimeout(connectionTimeoutRef.current);\n          }\n          setIsConnected(true);\n          setConnectionStatus('connected');\n          setIsMockMode(false);\n          reconnectAttemptsRef.current = 0;\n          console.log('WebSocket connected');\n          \n          // Start ping interval\n          pingIntervalRef.current = setInterval(() => {\n            if (ws.readyState === WebSocket.OPEN) {\n              lastPingRef.current = Date.now();\n              ws.send(JSON.stringify({ type: 'ping' }));\n            }\n          }, 30000);\n          \n          // Resubscribe to symbols\n          subscriptionsRef.current.forEach(symbol => {\n            ws.send(JSON.stringify({ type: 'subscribe', symbol }));\n          });\n          \n          toast.success('Connected to real-time data feed', {\n            duration: 2000,\n            icon: 'âœ…'\n          });\n        };\n\n        ws.onmessage = (event) => {\n          try {\n            const message: WebSocketMessage = JSON.parse(event.data);\n            \n            if (message.type === 'pong') {\n              const now = Date.now();\n              const newLatency = now - lastPingRef.current;\n              setLatency(newLatency);\n            } else if (message.type === 'market_data_update') {\n              console.log('Market data update:', message);\n            } else if (message.type === 'subscription_response') {\n              if (message.symbol && message.success) {\n                console.log(`Subscribed to ${message.symbol}`);\n              }\n            } else if (message.type === 'unsubscription_response') {\n              if (message.symbol && message.success) {\n                console.log(`Unsubscribed from ${message.symbol}`);\n              }\n            }\n          } catch (error) {\n            console.error('Failed to parse WebSocket message:', error);\n          }\n        };\n\n        ws.onclose = (event) => {\n          if (connectionTimeoutRef.current) {\n            clearTimeout(connectionTimeoutRef.current);\n          }\n          setIsConnected(false);\n          setConnectionStatus('disconnected');\n          console.log('WebSocket disconnected:', event.code, event.reason);\n          \n          // Clear intervals\n          if (pingIntervalRef.current) {\n            clearInterval(pingIntervalRef.current);\n          }\n          \n          // If this is the first connection attempt and it fails, switch to mock mode immediately\n          if (reconnectAttemptsRef.current === 0) {\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n            return;\n          }\n          \n          // Attempt to reconnect if not a normal closure and we haven't exceeded max attempts\n          if (event.code !== 1000 && reconnectAttemptsRef.current < maxReconnectAttempts) {\n            reconnectAttemptsRef.current++;\n            const delay = Math.min(500 * Math.pow(2, reconnectAttemptsRef.current), 3000); // Max 3s delay, reduced from 10s\n            \n            console.log(`Attempting to reconnect in ${delay}ms (attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts})...`);\n            reconnectTimeoutRef.current = setTimeout(() => {\n              connect();\n            }, delay);\n          } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n            setConnectionStatus('error');\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n          }\n        };\n\n        ws.onerror = (error) => {\n          if (connectionTimeoutRef.current) {\n            clearTimeout(connectionTimeoutRef.current);\n          }\n          console.error('WebSocket error:', error);\n          setConnectionStatus('error');\n          \n          // If this is the first connection attempt, switch to mock mode immediately\n          if (reconnectAttemptsRef.current === 0) {\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n          }\n        };\n      });\n\n    } catch (error) {\n      if (connectionTimeoutRef.current) {\n        clearTimeout(connectionTimeoutRef.current);\n      }\n      console.error('Failed to create WebSocket connection:', error);\n      setConnectionStatus('error');\n      setIsMockMode(true);\n      toast.success('Using simulated data mode. All features are fully functional!', {\n        duration: 3000,\n        icon: 'ðŸŽ¯'\n      });\n    }\n  }, []);\n\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, 'Client disconnect');\n      wsRef.current = null;\n    }\n    \n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    \n    if (connectionTimeoutRef.current) {\n      clearTimeout(connectionTimeoutRef.current);\n    }\n    \n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n    }\n    \n    if (mockLatencyRef.current) {\n      clearInterval(mockLatencyRef.current);\n    }\n    \n    setIsConnected(false);\n    setConnectionStatus('disconnected');\n    setIsMockMode(false);\n    reconnectAttemptsRef.current = 0;\n  }, []);\n\n  const subscribe = useCallback((symbol: string) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({ type: 'subscribe', symbol }));\n      subscriptionsRef.current.add(symbol);\n    } else {\n      // Store subscription for when connection is established\n      subscriptionsRef.current.add(symbol);\n    }\n  }, []);\n\n  const unsubscribe = useCallback((symbol: string) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({ type: 'unsubscribe', symbol }));\n    }\n    subscriptionsRef.current.delete(symbol);\n  }, []);\n\n  const sendMessage = useCallback((message: any) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('WebSocket not connected, cannot send message:', message);\n    }\n  }, []);\n\n  // Start mock latency simulation when in mock mode\n  useEffect(() => {\n    if (isMockMode) {\n      mockLatencyRef.current = setInterval(() => {\n        setLatency(Math.floor(Math.random() * 30) + 5); // Random latency between 5-35ms (faster)\n      }, 3000); // Update every 3 seconds instead of 5\n    } else {\n      if (mockLatencyRef.current) {\n        clearInterval(mockLatencyRef.current);\n      }\n    }\n\n    return () => {\n      if (mockLatencyRef.current) {\n        clearInterval(mockLatencyRef.current);\n      }\n    };\n  }, [isMockMode]);\n\n  // Auto-connect on mount with immediate fallback\n  useEffect(() => {\n    // Start connection attempt\n    connect();\n    \n    // Set a very short fallback timeout (1.5 seconds)\n    const fallbackTimeout = setTimeout(() => {\n      if (!isConnected && !isMockMode) {\n        setIsMockMode(true);\n        toast.success('Using simulated data mode. All features are fully functional!', {\n          duration: 3000,\n          icon: 'ðŸŽ¯'\n        });\n      }\n    }, 1500);\n    \n    return () => {\n      clearTimeout(fallbackTimeout);\n      disconnect();\n    };\n  }, [connect, disconnect, isConnected, isMockMode]);\n\n  return {\n    isConnected,\n    latency,\n    subscribe,\n    unsubscribe,\n    sendMessage,\n    connectionStatus,\n    isMockMode\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}