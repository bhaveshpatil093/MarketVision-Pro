{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nimport toast from 'react-hot-toast';\nexport const useWebSocket = () => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const [latency, setLatency] = useState(0);\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\n  const [isMockMode, setIsMockMode] = useState(false);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef();\n  const pingIntervalRef = useRef();\n  const lastPingRef = useRef(0);\n  const subscriptionsRef = useRef(new Set());\n  const reconnectAttemptsRef = useRef(0);\n  const maxReconnectAttempts = 2; // Reduced from 3 to 2\n  const mockLatencyRef = useRef();\n  const connectionTimeoutRef = useRef();\n  const connect = useCallback(() => {\n    var _wsRef$current;\n    if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN) {\n      return; // Already connected\n    }\n\n    // Clear any existing timeout\n    if (connectionTimeoutRef.current) {\n      clearTimeout(connectionTimeoutRef.current);\n    }\n    try {\n      setConnectionStatus('connecting');\n\n      // Quick backend availability check with better error handling\n      const quickCheck = async () => {\n        try {\n          const controller = new AbortController();\n          const timeoutId = setTimeout(() => controller.abort(), 500);\n          const response = await fetch('http://localhost:8000/health', {\n            method: 'GET',\n            signal: controller.signal,\n            mode: 'cors',\n            headers: {\n              'Accept': 'application/json',\n              'Content-Type': 'application/json'\n            }\n          });\n          clearTimeout(timeoutId);\n          return response.ok;\n        } catch (error) {\n          // Handle any fetch errors (including Chrome extension interference)\n          console.log('Backend health check failed:', error);\n          return false;\n        }\n      };\n      quickCheck().then(isBackendAvailable => {\n        if (!isBackendAvailable) {\n          // Backend not available, switch to mock mode\n          setConnectionStatus('error');\n          setIsMockMode(true);\n          toast.success('Using simulated data mode. All features are fully functional!', {\n            duration: 3000,\n            icon: 'ðŸŽ¯'\n          });\n          return;\n        }\n\n        // Backend is available, proceed with WebSocket connection\n        // Set a very short connection timeout (1.5 seconds)\n        connectionTimeoutRef.current = setTimeout(() => {\n          var _wsRef$current2;\n          if (((_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.readyState) !== WebSocket.OPEN) {\n            var _wsRef$current3;\n            (_wsRef$current3 = wsRef.current) === null || _wsRef$current3 === void 0 ? void 0 : _wsRef$current3.close();\n            setConnectionStatus('error');\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n          }\n        }, 1500); // Reduced from 2 seconds to 1.5 seconds\n\n        const ws = new WebSocket('ws://localhost:8000/ws/market-data');\n        wsRef.current = ws;\n        ws.onopen = () => {\n          if (connectionTimeoutRef.current) {\n            clearTimeout(connectionTimeoutRef.current);\n          }\n          setIsConnected(true);\n          setConnectionStatus('connected');\n          setIsMockMode(false);\n          reconnectAttemptsRef.current = 0;\n          console.log('WebSocket connected');\n\n          // Start ping interval\n          pingIntervalRef.current = setInterval(() => {\n            if (ws.readyState === WebSocket.OPEN) {\n              lastPingRef.current = Date.now();\n              ws.send(JSON.stringify({\n                type: 'ping'\n              }));\n            }\n          }, 30000);\n\n          // Resubscribe to symbols\n          subscriptionsRef.current.forEach(symbol => {\n            ws.send(JSON.stringify({\n              type: 'subscribe',\n              symbol\n            }));\n          });\n          toast.success('Connected to real-time data feed', {\n            duration: 2000,\n            icon: 'âœ…'\n          });\n        };\n        ws.onmessage = event => {\n          try {\n            const message = JSON.parse(event.data);\n            if (message.type === 'pong') {\n              const now = Date.now();\n              const newLatency = now - lastPingRef.current;\n              setLatency(newLatency);\n            } else if (message.type === 'market_data_update') {\n              console.log('Market data update:', message);\n            } else if (message.type === 'subscription_response') {\n              if (message.symbol && message.success) {\n                console.log(`Subscribed to ${message.symbol}`);\n              }\n            } else if (message.type === 'unsubscription_response') {\n              if (message.symbol && message.success) {\n                console.log(`Unsubscribed from ${message.symbol}`);\n              }\n            }\n          } catch (error) {\n            console.error('Failed to parse WebSocket message:', error);\n          }\n        };\n        ws.onclose = event => {\n          if (connectionTimeoutRef.current) {\n            clearTimeout(connectionTimeoutRef.current);\n          }\n          setIsConnected(false);\n          setConnectionStatus('disconnected');\n          console.log('WebSocket disconnected:', event.code, event.reason);\n\n          // Clear intervals\n          if (pingIntervalRef.current) {\n            clearInterval(pingIntervalRef.current);\n          }\n\n          // If this is the first connection attempt and it fails, switch to mock mode immediately\n          if (reconnectAttemptsRef.current === 0) {\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n            return;\n          }\n\n          // Attempt to reconnect if not a normal closure and we haven't exceeded max attempts\n          if (event.code !== 1000 && reconnectAttemptsRef.current < maxReconnectAttempts) {\n            reconnectAttemptsRef.current++;\n            const delay = Math.min(500 * Math.pow(2, reconnectAttemptsRef.current), 3000); // Max 3s delay, reduced from 10s\n\n            console.log(`Attempting to reconnect in ${delay}ms (attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts})...`);\n            reconnectTimeoutRef.current = setTimeout(() => {\n              connect();\n            }, delay);\n          } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n            setConnectionStatus('error');\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n          }\n        };\n        ws.onerror = error => {\n          if (connectionTimeoutRef.current) {\n            clearTimeout(connectionTimeoutRef.current);\n          }\n          console.error('WebSocket error:', error);\n          setConnectionStatus('error');\n\n          // If this is the first connection attempt, switch to mock mode immediately\n          if (reconnectAttemptsRef.current === 0) {\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n          }\n        };\n      });\n    } catch (error) {\n      if (connectionTimeoutRef.current) {\n        clearTimeout(connectionTimeoutRef.current);\n      }\n      console.error('Failed to create WebSocket connection:', error);\n      setConnectionStatus('error');\n      setIsMockMode(true);\n      toast.success('Using simulated data mode. All features are fully functional!', {\n        duration: 3000,\n        icon: 'ðŸŽ¯'\n      });\n    }\n  }, []);\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, 'Client disconnect');\n      wsRef.current = null;\n    }\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    if (connectionTimeoutRef.current) {\n      clearTimeout(connectionTimeoutRef.current);\n    }\n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n    }\n    if (mockLatencyRef.current) {\n      clearInterval(mockLatencyRef.current);\n    }\n    setIsConnected(false);\n    setConnectionStatus('disconnected');\n    setIsMockMode(false);\n    reconnectAttemptsRef.current = 0;\n  }, []);\n  const subscribe = useCallback(symbol => {\n    var _wsRef$current4;\n    if (((_wsRef$current4 = wsRef.current) === null || _wsRef$current4 === void 0 ? void 0 : _wsRef$current4.readyState) === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'subscribe',\n        symbol\n      }));\n      subscriptionsRef.current.add(symbol);\n    } else {\n      // Store subscription for when connection is established\n      subscriptionsRef.current.add(symbol);\n    }\n  }, []);\n  const unsubscribe = useCallback(symbol => {\n    var _wsRef$current5;\n    if (((_wsRef$current5 = wsRef.current) === null || _wsRef$current5 === void 0 ? void 0 : _wsRef$current5.readyState) === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'unsubscribe',\n        symbol\n      }));\n    }\n    subscriptionsRef.current.delete(symbol);\n  }, []);\n  const sendMessage = useCallback(message => {\n    var _wsRef$current6;\n    if (((_wsRef$current6 = wsRef.current) === null || _wsRef$current6 === void 0 ? void 0 : _wsRef$current6.readyState) === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('WebSocket not connected, cannot send message:', message);\n    }\n  }, []);\n\n  // Start mock latency simulation when in mock mode\n  useEffect(() => {\n    if (isMockMode) {\n      mockLatencyRef.current = setInterval(() => {\n        setLatency(Math.floor(Math.random() * 30) + 5); // Random latency between 5-35ms (faster)\n      }, 3000); // Update every 3 seconds instead of 5\n    } else {\n      if (mockLatencyRef.current) {\n        clearInterval(mockLatencyRef.current);\n      }\n    }\n    return () => {\n      if (mockLatencyRef.current) {\n        clearInterval(mockLatencyRef.current);\n      }\n    };\n  }, [isMockMode]);\n\n  // Auto-connect on mount with immediate fallback\n  useEffect(() => {\n    // Start connection attempt\n    connect();\n\n    // Set a very short fallback timeout (1 second)\n    const fallbackTimeout = setTimeout(() => {\n      if (!isConnected && !isMockMode) {\n        setIsMockMode(true);\n        toast.success('Using simulated data mode. All features are fully functional!', {\n          duration: 3000,\n          icon: 'ðŸŽ¯'\n        });\n      }\n    }, 1000); // Reduced from 1.5 seconds to 1 second\n\n    return () => {\n      clearTimeout(fallbackTimeout);\n      disconnect();\n    };\n  }, [connect, disconnect, isConnected, isMockMode]);\n  return {\n    isConnected,\n    latency,\n    subscribe,\n    unsubscribe,\n    sendMessage,\n    connectionStatus,\n    isMockMode\n  };\n};\n_s(useWebSocket, \"DCpKg4qlTwd6r2F3/pajNAPnbMo=\");","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","toast","useWebSocket","_s","isConnected","setIsConnected","latency","setLatency","connectionStatus","setConnectionStatus","isMockMode","setIsMockMode","wsRef","reconnectTimeoutRef","pingIntervalRef","lastPingRef","subscriptionsRef","Set","reconnectAttemptsRef","maxReconnectAttempts","mockLatencyRef","connectionTimeoutRef","connect","_wsRef$current","current","readyState","WebSocket","OPEN","clearTimeout","quickCheck","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","method","signal","mode","headers","ok","error","console","log","then","isBackendAvailable","success","duration","icon","_wsRef$current2","_wsRef$current3","close","ws","onopen","setInterval","Date","now","send","JSON","stringify","type","forEach","symbol","onmessage","event","message","parse","data","newLatency","onclose","code","reason","clearInterval","delay","Math","min","pow","onerror","disconnect","subscribe","_wsRef$current4","add","unsubscribe","_wsRef$current5","delete","sendMessage","_wsRef$current6","warn","floor","random","fallbackTimeout"],"sources":["/Users/bhaveshpatil/Developer/HFT Projects/1/MarketVision-Pro/frontend/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\nimport toast from 'react-hot-toast';\n\ninterface WebSocketMessage {\n  type: string;\n  symbol?: string;\n  data?: any;\n  timestamp: string;\n  success?: boolean;\n}\n\ninterface UseWebSocketReturn {\n  isConnected: boolean;\n  latency: number;\n  subscribe: (symbol: string) => void;\n  unsubscribe: (symbol: string) => void;\n  sendMessage: (message: any) => void;\n  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';\n  isMockMode: boolean;\n}\n\nexport const useWebSocket = (): UseWebSocketReturn => {\n  const [isConnected, setIsConnected] = useState(false);\n  const [latency, setLatency] = useState(0);\n  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected');\n  const [isMockMode, setIsMockMode] = useState(false);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();\n  const pingIntervalRef = useRef<NodeJS.Timeout>();\n  const lastPingRef = useRef<number>(0);\n  const subscriptionsRef = useRef<Set<string>>(new Set());\n  const reconnectAttemptsRef = useRef<number>(0);\n  const maxReconnectAttempts = 2; // Reduced from 3 to 2\n  const mockLatencyRef = useRef<NodeJS.Timeout>();\n  const connectionTimeoutRef = useRef<NodeJS.Timeout>();\n\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return; // Already connected\n    }\n\n    // Clear any existing timeout\n    if (connectionTimeoutRef.current) {\n      clearTimeout(connectionTimeoutRef.current);\n    }\n\n    try {\n      setConnectionStatus('connecting');\n      \n      // Quick backend availability check with better error handling\n      const quickCheck = async () => {\n        try {\n          const controller = new AbortController();\n          const timeoutId = setTimeout(() => controller.abort(), 500);\n          \n          const response = await fetch('http://localhost:8000/health', { \n            method: 'GET',\n            signal: controller.signal,\n            mode: 'cors',\n            headers: {\n              'Accept': 'application/json',\n              'Content-Type': 'application/json'\n            }\n          });\n          \n          clearTimeout(timeoutId);\n          return response.ok;\n        } catch (error) {\n          // Handle any fetch errors (including Chrome extension interference)\n          console.log('Backend health check failed:', error);\n          return false;\n        }\n      };\n\n      quickCheck().then((isBackendAvailable) => {\n        if (!isBackendAvailable) {\n          // Backend not available, switch to mock mode\n          setConnectionStatus('error');\n          setIsMockMode(true);\n          toast.success('Using simulated data mode. All features are fully functional!', {\n            duration: 3000,\n            icon: 'ðŸŽ¯'\n          });\n          return;\n        }\n\n        // Backend is available, proceed with WebSocket connection\n        // Set a very short connection timeout (1.5 seconds)\n        connectionTimeoutRef.current = setTimeout(() => {\n          if (wsRef.current?.readyState !== WebSocket.OPEN) {\n            wsRef.current?.close();\n            setConnectionStatus('error');\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n          }\n        }, 1500); // Reduced from 2 seconds to 1.5 seconds\n\n        const ws = new WebSocket('ws://localhost:8000/ws/market-data');\n        wsRef.current = ws;\n\n        ws.onopen = () => {\n          if (connectionTimeoutRef.current) {\n            clearTimeout(connectionTimeoutRef.current);\n          }\n          setIsConnected(true);\n          setConnectionStatus('connected');\n          setIsMockMode(false);\n          reconnectAttemptsRef.current = 0;\n          console.log('WebSocket connected');\n          \n          // Start ping interval\n          pingIntervalRef.current = setInterval(() => {\n            if (ws.readyState === WebSocket.OPEN) {\n              lastPingRef.current = Date.now();\n              ws.send(JSON.stringify({ type: 'ping' }));\n            }\n          }, 30000);\n          \n          // Resubscribe to symbols\n          subscriptionsRef.current.forEach(symbol => {\n            ws.send(JSON.stringify({ type: 'subscribe', symbol }));\n          });\n          \n          toast.success('Connected to real-time data feed', {\n            duration: 2000,\n            icon: 'âœ…'\n          });\n        };\n\n        ws.onmessage = (event) => {\n          try {\n            const message: WebSocketMessage = JSON.parse(event.data);\n            \n            if (message.type === 'pong') {\n              const now = Date.now();\n              const newLatency = now - lastPingRef.current;\n              setLatency(newLatency);\n            } else if (message.type === 'market_data_update') {\n              console.log('Market data update:', message);\n            } else if (message.type === 'subscription_response') {\n              if (message.symbol && message.success) {\n                console.log(`Subscribed to ${message.symbol}`);\n              }\n            } else if (message.type === 'unsubscription_response') {\n              if (message.symbol && message.success) {\n                console.log(`Unsubscribed from ${message.symbol}`);\n              }\n            }\n          } catch (error) {\n            console.error('Failed to parse WebSocket message:', error);\n          }\n        };\n\n        ws.onclose = (event) => {\n          if (connectionTimeoutRef.current) {\n            clearTimeout(connectionTimeoutRef.current);\n          }\n          setIsConnected(false);\n          setConnectionStatus('disconnected');\n          console.log('WebSocket disconnected:', event.code, event.reason);\n          \n          // Clear intervals\n          if (pingIntervalRef.current) {\n            clearInterval(pingIntervalRef.current);\n          }\n          \n          // If this is the first connection attempt and it fails, switch to mock mode immediately\n          if (reconnectAttemptsRef.current === 0) {\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n            return;\n          }\n          \n          // Attempt to reconnect if not a normal closure and we haven't exceeded max attempts\n          if (event.code !== 1000 && reconnectAttemptsRef.current < maxReconnectAttempts) {\n            reconnectAttemptsRef.current++;\n            const delay = Math.min(500 * Math.pow(2, reconnectAttemptsRef.current), 3000); // Max 3s delay, reduced from 10s\n            \n            console.log(`Attempting to reconnect in ${delay}ms (attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts})...`);\n            reconnectTimeoutRef.current = setTimeout(() => {\n              connect();\n            }, delay);\n          } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n            setConnectionStatus('error');\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n          }\n        };\n\n        ws.onerror = (error) => {\n          if (connectionTimeoutRef.current) {\n            clearTimeout(connectionTimeoutRef.current);\n          }\n          console.error('WebSocket error:', error);\n          setConnectionStatus('error');\n          \n          // If this is the first connection attempt, switch to mock mode immediately\n          if (reconnectAttemptsRef.current === 0) {\n            setIsMockMode(true);\n            toast.success('Using simulated data mode. All features are fully functional!', {\n              duration: 3000,\n              icon: 'ðŸŽ¯'\n            });\n          }\n        };\n      });\n\n    } catch (error) {\n      if (connectionTimeoutRef.current) {\n        clearTimeout(connectionTimeoutRef.current);\n      }\n      console.error('Failed to create WebSocket connection:', error);\n      setConnectionStatus('error');\n      setIsMockMode(true);\n      toast.success('Using simulated data mode. All features are fully functional!', {\n        duration: 3000,\n        icon: 'ðŸŽ¯'\n      });\n    }\n  }, []);\n\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, 'Client disconnect');\n      wsRef.current = null;\n    }\n    \n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    \n    if (connectionTimeoutRef.current) {\n      clearTimeout(connectionTimeoutRef.current);\n    }\n    \n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n    }\n    \n    if (mockLatencyRef.current) {\n      clearInterval(mockLatencyRef.current);\n    }\n    \n    setIsConnected(false);\n    setConnectionStatus('disconnected');\n    setIsMockMode(false);\n    reconnectAttemptsRef.current = 0;\n  }, []);\n\n  const subscribe = useCallback((symbol: string) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({ type: 'subscribe', symbol }));\n      subscriptionsRef.current.add(symbol);\n    } else {\n      // Store subscription for when connection is established\n      subscriptionsRef.current.add(symbol);\n    }\n  }, []);\n\n  const unsubscribe = useCallback((symbol: string) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({ type: 'unsubscribe', symbol }));\n    }\n    subscriptionsRef.current.delete(symbol);\n  }, []);\n\n  const sendMessage = useCallback((message: any) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('WebSocket not connected, cannot send message:', message);\n    }\n  }, []);\n\n  // Start mock latency simulation when in mock mode\n  useEffect(() => {\n    if (isMockMode) {\n      mockLatencyRef.current = setInterval(() => {\n        setLatency(Math.floor(Math.random() * 30) + 5); // Random latency between 5-35ms (faster)\n      }, 3000); // Update every 3 seconds instead of 5\n    } else {\n      if (mockLatencyRef.current) {\n        clearInterval(mockLatencyRef.current);\n      }\n    }\n\n    return () => {\n      if (mockLatencyRef.current) {\n        clearInterval(mockLatencyRef.current);\n      }\n    };\n  }, [isMockMode]);\n\n  // Auto-connect on mount with immediate fallback\n  useEffect(() => {\n    // Start connection attempt\n    connect();\n    \n    // Set a very short fallback timeout (1 second)\n    const fallbackTimeout = setTimeout(() => {\n      if (!isConnected && !isMockMode) {\n        setIsMockMode(true);\n        toast.success('Using simulated data mode. All features are fully functional!', {\n          duration: 3000,\n          icon: 'ðŸŽ¯'\n        });\n      }\n    }, 1000); // Reduced from 1.5 seconds to 1 second\n    \n    return () => {\n      clearTimeout(fallbackTimeout);\n      disconnect();\n    };\n  }, [connect, disconnect, isConnected, isMockMode]);\n\n  return {\n    isConnected,\n    latency,\n    subscribe,\n    unsubscribe,\n    sendMessage,\n    connectionStatus,\n    isMockMode\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}