{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nimport toast from 'react-hot-toast';\nexport const useWebSocket = () => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const [latency, setLatency] = useState(0);\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef();\n  const pingIntervalRef = useRef();\n  const lastPingRef = useRef(0);\n  const subscriptionsRef = useRef(new Set());\n  const reconnectAttemptsRef = useRef(0);\n  const maxReconnectAttempts = 5;\n  const connect = useCallback(() => {\n    var _wsRef$current;\n    if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN) {\n      return; // Already connected\n    }\n    try {\n      setConnectionStatus('connecting');\n      const ws = new WebSocket('ws://localhost:8000/ws/market-data');\n      wsRef.current = ws;\n      ws.onopen = () => {\n        setIsConnected(true);\n        setConnectionStatus('connected');\n        reconnectAttemptsRef.current = 0; // Reset reconnect attempts on successful connection\n        console.log('WebSocket connected');\n\n        // Start ping interval\n        pingIntervalRef.current = setInterval(() => {\n          if (ws.readyState === WebSocket.OPEN) {\n            lastPingRef.current = Date.now();\n            ws.send(JSON.stringify({\n              type: 'ping'\n            }));\n          }\n        }, 30000); // Ping every 30 seconds\n\n        // Resubscribe to symbols\n        subscriptionsRef.current.forEach(symbol => {\n          ws.send(JSON.stringify({\n            type: 'subscribe',\n            symbol\n          }));\n        });\n        toast.success('Connected to real-time data feed');\n      };\n      ws.onmessage = event => {\n        try {\n          const message = JSON.parse(event.data);\n          if (message.type === 'pong') {\n            const now = Date.now();\n            const newLatency = now - lastPingRef.current;\n            setLatency(newLatency);\n          } else if (message.type === 'market_data_update') {\n            // Handle market data updates\n            console.log('Market data update:', message);\n          } else if (message.type === 'subscription_response') {\n            if (message.symbol && message.success) {\n              console.log(`Subscribed to ${message.symbol}`);\n            }\n          } else if (message.type === 'unsubscription_response') {\n            if (message.symbol && message.success) {\n              console.log(`Unsubscribed from ${message.symbol}`);\n            }\n          }\n        } catch (error) {\n          console.error('Failed to parse WebSocket message:', error);\n        }\n      };\n      ws.onclose = event => {\n        setIsConnected(false);\n        setConnectionStatus('disconnected');\n        console.log('WebSocket disconnected:', event.code, event.reason);\n\n        // Clear intervals\n        if (pingIntervalRef.current) {\n          clearInterval(pingIntervalRef.current);\n        }\n\n        // Attempt to reconnect if not a normal closure and we haven't exceeded max attempts\n        if (event.code !== 1000 && reconnectAttemptsRef.current < maxReconnectAttempts) {\n          reconnectAttemptsRef.current++;\n          const delay = Math.min(1000 * Math.pow(2, reconnectAttemptsRef.current), 30000); // Exponential backoff, max 30s\n\n          console.log(`Attempting to reconnect in ${delay}ms (attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts})...`);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, delay);\n        } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n          setConnectionStatus('error');\n          toast.error('Failed to connect after multiple attempts. Please check if the backend is running.');\n        }\n        if (event.code !== 1000) {\n          toast.error('Disconnected from real-time data feed');\n        }\n      };\n      ws.onerror = error => {\n        console.error('WebSocket error:', error);\n        setConnectionStatus('error');\n\n        // Don't show error toast immediately, let onclose handle it\n        // This prevents multiple error messages\n      };\n    } catch (error) {\n      console.error('Failed to create WebSocket connection:', error);\n      setConnectionStatus('error');\n      toast.error('Failed to establish WebSocket connection');\n    }\n  }, []);\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, 'Client disconnect');\n      wsRef.current = null;\n    }\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n    }\n    setIsConnected(false);\n    setConnectionStatus('disconnected');\n    reconnectAttemptsRef.current = 0;\n  }, []);\n  const subscribe = useCallback(symbol => {\n    var _wsRef$current2;\n    if (((_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.readyState) === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'subscribe',\n        symbol\n      }));\n      subscriptionsRef.current.add(symbol);\n    } else {\n      // Store subscription for when connection is established\n      subscriptionsRef.current.add(symbol);\n    }\n  }, []);\n  const unsubscribe = useCallback(symbol => {\n    var _wsRef$current3;\n    if (((_wsRef$current3 = wsRef.current) === null || _wsRef$current3 === void 0 ? void 0 : _wsRef$current3.readyState) === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'unsubscribe',\n        symbol\n      }));\n    }\n    subscriptionsRef.current.delete(symbol);\n  }, []);\n  const sendMessage = useCallback(message => {\n    var _wsRef$current4;\n    if (((_wsRef$current4 = wsRef.current) === null || _wsRef$current4 === void 0 ? void 0 : _wsRef$current4.readyState) === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('WebSocket not connected, cannot send message:', message);\n    }\n  }, []);\n\n  // Auto-connect on mount\n  useEffect(() => {\n    connect();\n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      disconnect();\n    };\n  }, [disconnect]);\n  return {\n    isConnected,\n    latency,\n    subscribe,\n    unsubscribe,\n    sendMessage,\n    connectionStatus\n  };\n};\n_s(useWebSocket, \"ZyZ7ilM+fAgGXrPAundj9kDD/7s=\");","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","toast","useWebSocket","_s","isConnected","setIsConnected","latency","setLatency","connectionStatus","setConnectionStatus","wsRef","reconnectTimeoutRef","pingIntervalRef","lastPingRef","subscriptionsRef","Set","reconnectAttemptsRef","maxReconnectAttempts","connect","_wsRef$current","current","readyState","WebSocket","OPEN","ws","onopen","console","log","setInterval","Date","now","send","JSON","stringify","type","forEach","symbol","success","onmessage","event","message","parse","data","newLatency","error","onclose","code","reason","clearInterval","delay","Math","min","pow","setTimeout","onerror","disconnect","close","clearTimeout","subscribe","_wsRef$current2","add","unsubscribe","_wsRef$current3","delete","sendMessage","_wsRef$current4","warn"],"sources":["/Users/bhaveshpatil/Developer/HFT Projects/1. MarketVision Pro/frontend/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\nimport toast from 'react-hot-toast';\n\ninterface WebSocketMessage {\n  type: string;\n  symbol?: string;\n  data?: any;\n  timestamp: string;\n  success?: boolean;\n}\n\ninterface UseWebSocketReturn {\n  isConnected: boolean;\n  latency: number;\n  subscribe: (symbol: string) => void;\n  unsubscribe: (symbol: string) => void;\n  sendMessage: (message: any) => void;\n  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';\n}\n\nexport const useWebSocket = (): UseWebSocketReturn => {\n  const [isConnected, setIsConnected] = useState(false);\n  const [latency, setLatency] = useState(0);\n  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected');\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();\n  const pingIntervalRef = useRef<NodeJS.Timeout>();\n  const lastPingRef = useRef<number>(0);\n  const subscriptionsRef = useRef<Set<string>>(new Set());\n  const reconnectAttemptsRef = useRef<number>(0);\n  const maxReconnectAttempts = 5;\n\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return; // Already connected\n    }\n\n    try {\n      setConnectionStatus('connecting');\n      const ws = new WebSocket('ws://localhost:8000/ws/market-data');\n      wsRef.current = ws;\n\n      ws.onopen = () => {\n        setIsConnected(true);\n        setConnectionStatus('connected');\n        reconnectAttemptsRef.current = 0; // Reset reconnect attempts on successful connection\n        console.log('WebSocket connected');\n        \n        // Start ping interval\n        pingIntervalRef.current = setInterval(() => {\n          if (ws.readyState === WebSocket.OPEN) {\n            lastPingRef.current = Date.now();\n            ws.send(JSON.stringify({ type: 'ping' }));\n          }\n        }, 30000); // Ping every 30 seconds\n        \n        // Resubscribe to symbols\n        subscriptionsRef.current.forEach(symbol => {\n          ws.send(JSON.stringify({ type: 'subscribe', symbol }));\n        });\n        \n        toast.success('Connected to real-time data feed');\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const message: WebSocketMessage = JSON.parse(event.data);\n          \n          if (message.type === 'pong') {\n            const now = Date.now();\n            const newLatency = now - lastPingRef.current;\n            setLatency(newLatency);\n          } else if (message.type === 'market_data_update') {\n            // Handle market data updates\n            console.log('Market data update:', message);\n          } else if (message.type === 'subscription_response') {\n            if (message.symbol && message.success) {\n              console.log(`Subscribed to ${message.symbol}`);\n            }\n          } else if (message.type === 'unsubscription_response') {\n            if (message.symbol && message.success) {\n              console.log(`Unsubscribed from ${message.symbol}`);\n            }\n          }\n        } catch (error) {\n          console.error('Failed to parse WebSocket message:', error);\n        }\n      };\n\n      ws.onclose = (event) => {\n        setIsConnected(false);\n        setConnectionStatus('disconnected');\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        \n        // Clear intervals\n        if (pingIntervalRef.current) {\n          clearInterval(pingIntervalRef.current);\n        }\n        \n        // Attempt to reconnect if not a normal closure and we haven't exceeded max attempts\n        if (event.code !== 1000 && reconnectAttemptsRef.current < maxReconnectAttempts) {\n          reconnectAttemptsRef.current++;\n          const delay = Math.min(1000 * Math.pow(2, reconnectAttemptsRef.current), 30000); // Exponential backoff, max 30s\n          \n          console.log(`Attempting to reconnect in ${delay}ms (attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts})...`);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, delay);\n        } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n          setConnectionStatus('error');\n          toast.error('Failed to connect after multiple attempts. Please check if the backend is running.');\n        }\n        \n        if (event.code !== 1000) {\n          toast.error('Disconnected from real-time data feed');\n        }\n      };\n\n      ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        setConnectionStatus('error');\n        \n        // Don't show error toast immediately, let onclose handle it\n        // This prevents multiple error messages\n      };\n\n    } catch (error) {\n      console.error('Failed to create WebSocket connection:', error);\n      setConnectionStatus('error');\n      toast.error('Failed to establish WebSocket connection');\n    }\n  }, []);\n\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, 'Client disconnect');\n      wsRef.current = null;\n    }\n    \n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    \n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n    }\n    \n    setIsConnected(false);\n    setConnectionStatus('disconnected');\n    reconnectAttemptsRef.current = 0;\n  }, []);\n\n  const subscribe = useCallback((symbol: string) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({ type: 'subscribe', symbol }));\n      subscriptionsRef.current.add(symbol);\n    } else {\n      // Store subscription for when connection is established\n      subscriptionsRef.current.add(symbol);\n    }\n  }, []);\n\n  const unsubscribe = useCallback((symbol: string) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({ type: 'unsubscribe', symbol }));\n    }\n    subscriptionsRef.current.delete(symbol);\n  }, []);\n\n  const sendMessage = useCallback((message: any) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('WebSocket not connected, cannot send message:', message);\n    }\n  }, []);\n\n  // Auto-connect on mount\n  useEffect(() => {\n    connect();\n    \n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      disconnect();\n    };\n  }, [disconnect]);\n\n  return {\n    isConnected,\n    latency,\n    subscribe,\n    unsubscribe,\n    sendMessage,\n    connectionStatus\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}