{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nimport toast from 'react-hot-toast';\nexport const useWebSocket = () => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const [latency, setLatency] = useState(0);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef();\n  const pingIntervalRef = useRef();\n  const lastPingRef = useRef(0);\n  const subscriptionsRef = useRef(new Set());\n  const connect = useCallback(() => {\n    try {\n      const ws = new WebSocket('ws://localhost:8000/ws/market-data');\n      wsRef.current = ws;\n      ws.onopen = () => {\n        setIsConnected(true);\n        console.log('WebSocket connected');\n\n        // Start ping interval\n        pingIntervalRef.current = setInterval(() => {\n          if (ws.readyState === WebSocket.OPEN) {\n            lastPingRef.current = Date.now();\n            ws.send(JSON.stringify({\n              type: 'ping'\n            }));\n          }\n        }, 30000); // Ping every 30 seconds\n\n        // Resubscribe to symbols\n        subscriptionsRef.current.forEach(symbol => {\n          ws.send(JSON.stringify({\n            type: 'subscribe',\n            symbol\n          }));\n        });\n        toast.success('Connected to real-time data feed');\n      };\n      ws.onmessage = event => {\n        try {\n          const message = JSON.parse(event.data);\n          if (message.type === 'pong') {\n            const now = Date.now();\n            const newLatency = now - lastPingRef.current;\n            setLatency(newLatency);\n          } else if (message.type === 'market_data_update') {\n            // Handle market data updates\n            console.log('Market data update:', message);\n          } else if (message.type === 'subscription_response') {\n            if (message.symbol && message.success) {\n              console.log(`Subscribed to ${message.symbol}`);\n            }\n          } else if (message.type === 'unsubscription_response') {\n            if (message.symbol && message.success) {\n              console.log(`Unsubscribed from ${message.symbol}`);\n            }\n          }\n        } catch (error) {\n          console.error('Failed to parse WebSocket message:', error);\n        }\n      };\n      ws.onclose = event => {\n        setIsConnected(false);\n        console.log('WebSocket disconnected:', event.code, event.reason);\n\n        // Clear intervals\n        if (pingIntervalRef.current) {\n          clearInterval(pingIntervalRef.current);\n        }\n\n        // Attempt to reconnect\n        if (event.code !== 1000) {\n          // Not a normal closure\n          reconnectTimeoutRef.current = setTimeout(() => {\n            console.log('Attempting to reconnect...');\n            connect();\n          }, 5000);\n        }\n        toast.error('Disconnected from real-time data feed');\n      };\n      ws.onerror = error => {\n        console.error('WebSocket error:', error);\n        toast.error('WebSocket connection error');\n      };\n    } catch (error) {\n      console.error('Failed to create WebSocket:', error);\n      toast.error('Failed to connect to WebSocket');\n    }\n  }, []);\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, 'User initiated disconnect');\n    }\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n    }\n  }, []);\n  const subscribe = useCallback(symbol => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'subscribe',\n        symbol\n      }));\n      subscriptionsRef.current.add(symbol);\n    }\n  }, []);\n  const unsubscribe = useCallback(symbol => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({\n        type: 'unsubscribe',\n        symbol\n      }));\n      subscriptionsRef.current.delete(symbol);\n    }\n  }, []);\n  const sendMessage = useCallback(message => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('WebSocket is not connected');\n    }\n  }, []);\n\n  // Connect on mount\n  useEffect(() => {\n    connect();\n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      disconnect();\n    };\n  }, [disconnect]);\n  return {\n    isConnected,\n    latency,\n    subscribe,\n    unsubscribe,\n    sendMessage\n  };\n};\n_s(useWebSocket, \"5+UnAGkcs5O/wFRAC1R0JrDOCao=\");","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","toast","useWebSocket","_s","isConnected","setIsConnected","latency","setLatency","wsRef","reconnectTimeoutRef","pingIntervalRef","lastPingRef","subscriptionsRef","Set","connect","ws","WebSocket","current","onopen","console","log","setInterval","readyState","OPEN","Date","now","send","JSON","stringify","type","forEach","symbol","success","onmessage","event","message","parse","data","newLatency","error","onclose","code","reason","clearInterval","setTimeout","onerror","disconnect","close","clearTimeout","subscribe","add","unsubscribe","delete","sendMessage","warn"],"sources":["/Users/bhaveshpatil/Developer/HFT Projects/1. MarketVision Pro/frontend/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\nimport toast from 'react-hot-toast';\n\ninterface WebSocketMessage {\n  type: string;\n  symbol?: string;\n  data?: any;\n  timestamp: string;\n  success?: boolean;\n}\n\ninterface UseWebSocketReturn {\n  isConnected: boolean;\n  latency: number;\n  subscribe: (symbol: string) => void;\n  unsubscribe: (symbol: string) => void;\n  sendMessage: (message: any) => void;\n}\n\nexport const useWebSocket = (): UseWebSocketReturn => {\n  const [isConnected, setIsConnected] = useState(false);\n  const [latency, setLatency] = useState(0);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();\n  const pingIntervalRef = useRef<NodeJS.Timeout>();\n  const lastPingRef = useRef<number>(0);\n  const subscriptionsRef = useRef<Set<string>>(new Set());\n\n  const connect = useCallback(() => {\n    try {\n      const ws = new WebSocket('ws://localhost:8000/ws/market-data');\n      wsRef.current = ws;\n\n      ws.onopen = () => {\n        setIsConnected(true);\n        console.log('WebSocket connected');\n        \n        // Start ping interval\n        pingIntervalRef.current = setInterval(() => {\n          if (ws.readyState === WebSocket.OPEN) {\n            lastPingRef.current = Date.now();\n            ws.send(JSON.stringify({ type: 'ping' }));\n          }\n        }, 30000); // Ping every 30 seconds\n        \n        // Resubscribe to symbols\n        subscriptionsRef.current.forEach(symbol => {\n          ws.send(JSON.stringify({ type: 'subscribe', symbol }));\n        });\n        \n        toast.success('Connected to real-time data feed');\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const message: WebSocketMessage = JSON.parse(event.data);\n          \n          if (message.type === 'pong') {\n            const now = Date.now();\n            const newLatency = now - lastPingRef.current;\n            setLatency(newLatency);\n          } else if (message.type === 'market_data_update') {\n            // Handle market data updates\n            console.log('Market data update:', message);\n          } else if (message.type === 'subscription_response') {\n            if (message.symbol && message.success) {\n              console.log(`Subscribed to ${message.symbol}`);\n            }\n          } else if (message.type === 'unsubscription_response') {\n            if (message.symbol && message.success) {\n              console.log(`Unsubscribed from ${message.symbol}`);\n            }\n          }\n        } catch (error) {\n          console.error('Failed to parse WebSocket message:', error);\n        }\n      };\n\n      ws.onclose = (event) => {\n        setIsConnected(false);\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        \n        // Clear intervals\n        if (pingIntervalRef.current) {\n          clearInterval(pingIntervalRef.current);\n        }\n        \n        // Attempt to reconnect\n        if (event.code !== 1000) { // Not a normal closure\n          reconnectTimeoutRef.current = setTimeout(() => {\n            console.log('Attempting to reconnect...');\n            connect();\n          }, 5000);\n        }\n        \n        toast.error('Disconnected from real-time data feed');\n      };\n\n      ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        toast.error('WebSocket connection error');\n      };\n\n    } catch (error) {\n      console.error('Failed to create WebSocket:', error);\n      toast.error('Failed to connect to WebSocket');\n    }\n  }, []);\n\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close(1000, 'User initiated disconnect');\n    }\n    \n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    \n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n    }\n  }, []);\n\n  const subscribe = useCallback((symbol: string) => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({ type: 'subscribe', symbol }));\n      subscriptionsRef.current.add(symbol);\n    }\n  }, []);\n\n  const unsubscribe = useCallback((symbol: string) => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({ type: 'unsubscribe', symbol }));\n      subscriptionsRef.current.delete(symbol);\n    }\n  }, []);\n\n  const sendMessage = useCallback((message: any) => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('WebSocket is not connected');\n    }\n  }, []);\n\n  // Connect on mount\n  useEffect(() => {\n    connect();\n    \n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      disconnect();\n    };\n  }, [disconnect]);\n\n  return {\n    isConnected,\n    latency,\n    subscribe,\n    unsubscribe,\n    sendMessage,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}